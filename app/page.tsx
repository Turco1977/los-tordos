"use client";
import { useState, useEffect, useMemo } from "react";
import dynamic from "next/dynamic";
import { createClient } from "@/lib/supabase/client";
import { T, AREAS, DEPTOS, ROLES, ST, SC, PST, FREQ, fn, isOD } from "@/lib/constants";
import { exportCSV, exportPDF, exportICal, exportMinutaPDF, exportMinutaWord, exportReportPDF, exportProjectPDF, exportAuditPDF } from "@/lib/export";
import { useTheme, darkCSS } from "@/lib/theme";
import { ThemeCtx } from "@/lib/theme-context";
import { Toast, useMobile, Btn, Card, Ring, Badge, Bread } from "@/components/ui";
import { taskToDB, presuToDB, presuFromDB, provFromDB } from "@/lib/mappers";
import { useDataStore } from "@/lib/store";
import { useOfflineData } from "@/lib/use-offline";
import { Login } from "@/components/main/Login";
import { ChangePw } from "@/components/main/ChangePw";
import { SB } from "@/components/main/Sidebar";
import { MyDash } from "@/components/main/MyDash";
import { Det } from "@/components/main/Det";
import { TList } from "@/components/main/TaskList";
import { KPIs } from "@/components/main/KPIs";
import { DeptCircles } from "@/components/main/DeptCircles";
import { Org } from "@/components/main/Org";
import { NP } from "@/components/main/NewPedido";
import { Proyecto } from "@/components/main/Proyecto";
import { Profs } from "@/components/main/Profs";
import PresView from "@/components/main/PresView";
import CalView from "@/components/main/CalView";
import { CustomDash } from "@/components/main/CustomDash";
import { ProyectosView } from "@/components/main/ProyectosView";
import { KanbanView } from "@/components/main/KanbanView";
import { ActivityFeed } from "@/components/main/ActivityFeed";
import { CommView } from "@/components/main/CommView";
import { CommReq } from "@/components/main/CommReq";
import { CommandPalette } from "@/components/main/CommandPalette";
import { RecurrentTasks } from "@/components/main/RecurrentTasks";
import { ErrorBoundary } from "@/components/ErrorBoundary";

// Dynamic imports for heavy views ‚Äî only loaded when navigated to
const SponsorsView = dynamic(() => import("@/components/main/SponsorsView").then(m => ({ default: m.SponsorsView })), { ssr: false });
const InventarioView = dynamic(() => import("@/components/main/InventarioView").then(m => ({ default: m.InventarioView })), { ssr: false });
const ReservasView = dynamic(() => import("@/components/main/ReservasView").then(m => ({ default: m.ReservasView })), { ssr: false });
const Reuniones = dynamic(() => import("@/components/main/Reuniones").then(m => ({ default: m.Reuniones })), { ssr: false });
const ArchivosView = dynamic(() => import("@/components/main/ArchivosView").then(m => ({ default: m.ArchivosView })), { ssr: false });
const NewFactura = dynamic(() => import("@/components/main/NewFactura").then(m => ({ default: m.NewFactura })), { ssr: false });

// Custom hooks
import { useAuth } from "@/hooks/useAuth";
import { useViews } from "@/hooks/useViews";
import { useSearch } from "@/hooks/useSearch";
import { useKeyboard } from "@/hooks/useKeyboard";
import { useTaskHandlers } from "@/hooks/useTaskHandlers";
import { useNotifications } from "@/hooks/useNotifications";
import { useDataFetch } from "@/hooks/useDataFetch";
import { useRealtimeSetup } from "@/hooks/useRealtimeSetup";
import { useRecurringTasks } from "@/hooks/useRecurringTasks";
import { useCommandPalette } from "@/hooks/useCommandPalette";
import { NotificationPanel } from "@/components/main/NotificationPanel";
import { AppHeader } from "@/components/main/AppHeader";

const supabase = createClient();
const TODAY = new Date().toISOString().slice(0, 10);

/* KPI filter helpers */
const KPIF: { [k: string]: { l: string; i: string; c: string } } = { ok: { l: "Completadas", i: "‚úÖ", c: T.gn }, pend: { l: "Pendientes", i: "üî¥", c: T.rd }, venc: { l: "Vencidas", i: "‚è∞", c: "#DC2626" }, gasto: { l: "Con Gasto", i: "üí∞", c: T.pr } };
const kpiFilter = (peds: any[], k: string) => { switch (k) { case "ok": return peds.filter(p => p.st === ST.OK); case "pend": return peds.filter(p => p.st === ST.P); case "venc": return peds.filter(p => p.st !== ST.OK && isOD(p.fReq)); case "gasto": return peds.filter(p => p.monto); default: return peds; } };

export default function App() {
  const mob = useMobile();
  const { mode: themeMode, toggle: toggleTheme, colors, isDark, cardBg, headerBg } = useTheme();
  const [toast, sToast] = useState<{ msg: string; type: "ok" | "err" } | null>(null);
  const showT = (msg: string, type: "ok" | "err" = "ok") => sToast({ msg, type });

  // Auth
  const auth = useAuth();
  const { user, authChecked, showPw, sShowPw, logout, getToken, isAd, isSA, isPersonal } = auth;

  // Offline
  const offline = useOfflineData(user);
  const { offlineState, loadFromCache, saveToCache, sync, cacheLoaded } = offline;

  // Views
  const views = useViews(!!isPersonal);
  const { vw, sVw, prevVw, sel, sSl, aA, sAA, aD, sAD, sbCol, sSbCol, sbOpen, sSbOpen, kpiFilt, sKpiFilt, preAT, sPreAT, mainRef, scrollTop, hAC, hDC, computeViewFilter, computeNav, areas, deptos } = views;

  // Search
  const search = useSearch();
  const { search: searchTerm, sSr, gsOpen, sGsOpen, gsRef, gsResults } = search;

  // Notifications
  const notifs = useNotifications(user, getToken);
  const { sendNotif, refreshNotifs, shNot, sShNot, computedNts, unreadDb, badgeCount, ntGrouped, ntColor, pushEnabled, requestPush, notifTotal, notifFilter, sNotifFilter, notifPage, sNotifPage, shNotifPrefs, sShNotifPrefs, NOTIF_LIMIT } = notifs;

  // Task handlers
  const tasks = useTaskHandlers(user, showT, sendNotif);
  const { addLog, handleBulk, handleImport, sanitize } = tasks;

  // Command palette
  const cmd = useCommandPalette(user, !!isPersonal, isDark, toggleTheme, sVw, sAA, sAD, sKpiFilt, sShowPw, sSl, logout);
  const { cmdOpen, sCmdOpen, cmdItems } = cmd;

  // Data fetching
  const data = useDataFetch(user, showT, saveToCache, loadFromCache, cacheLoaded);
  const { dataLoading, fetchAll } = data;

  // Keyboard shortcuts
  useKeyboard({ user, cmdOpen, sel, showPw, isPersonal: !!isPersonal, sVw, sCmdOpen, sAA, sAD, sKpiFilt });

  // Realtime subscriptions
  useRealtimeSetup(offlineState.isOnline, user, refreshNotifs);

  // Recurring tasks
  useRecurringTasks(user, dataLoading, fetchAll);

  // Store access
  const { users, om, peds, hitos, presu, provs, reminders, projects, projTasks, taskTemplates, projBudgets, inventory, invMaint, invDist, bookings, sponsors, sponMsgs, sponDeliveries, archivos, dbNotifs, sUs, sOm, sPd, sHi, sAgs, sMins, sPr, sPv, sRems, sProjects, sProjTasks, sTaskTemplates, sProjBudgets, sInventory, sInvMaint, sInvDist, sBookings, sSponsors, sSponMsgs, sSponDeliveries, sArchivos, sDbNotifs } = useDataStore();

  // Canje usage per sponsor
  const canjeUsado = useMemo(() => { const m: Record<number, number> = {}; presu.forEach((pr: any) => { if (pr.is_canje && pr.sponsor_id && pr.status === "aprobado") { m[pr.sponsor_id] = (m[pr.sponsor_id] || 0) + Number(pr.monto || 0); } }); sponDeliveries.forEach((d: any) => { if (d.sponsor_id) { m[d.sponsor_id] = (m[d.sponsor_id] || 0) + Number(d.total_value || 0); } }); return m; }, [presu, sponDeliveries]);

  // Expose audit PDF export
  useEffect(() => { (window as any).exportAuditPDF = () => exportAuditPDF(users); return () => { delete (window as any).exportAuditPDF; }; }, [users]);

  // ‚îÄ‚îÄ EARLY RETURNS ‚îÄ‚îÄ
  if (!authChecked) return <div style={{ minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center", background: colors.g1 }}><div style={{ fontSize: 14, color: colors.g4 }}>Cargando...</div></div>;
  if (!user) return <Login onLogin={(u: any) => auth.sU(u)} mob={mob} />;

  // Computed values (after early returns is OK ‚Äî not hooks)
  const nav = computeNav();
  const { vT, vI, vC, vP } = computeViewFilter(peds);

  if (isPersonal && vw === "dash") { setTimeout(() => sVw("my"), 0); return null; }

  return (
    <ErrorBoundary>
    <ThemeCtx.Provider value={{ colors, isDark, cardBg }}>
    <style dangerouslySetInnerHTML={{ __html: darkCSS }} />
    <a href="#main-content" style={{ position: "absolute", left: -9999, top: "auto", width: 1, height: 1, overflow: "hidden", zIndex: 9999 }} onFocus={e => { e.currentTarget.style.position = "fixed"; e.currentTarget.style.left = "8px"; e.currentTarget.style.top = "8px"; e.currentTarget.style.width = "auto"; e.currentTarget.style.height = "auto"; e.currentTarget.style.overflow = "visible"; e.currentTarget.style.padding = "8px 16px"; e.currentTarget.style.background = colors.nv; e.currentTarget.style.color = "#fff"; e.currentTarget.style.borderRadius = "8px"; e.currentTarget.style.fontSize = "13px"; e.currentTarget.style.fontWeight = "700"; e.currentTarget.style.textDecoration = "none"; }} onBlur={e => { e.currentTarget.style.position = "absolute"; e.currentTarget.style.left = "-9999px"; e.currentTarget.style.width = "1px"; e.currentTarget.style.height = "1px"; e.currentTarget.style.overflow = "hidden"; }}>Ir al contenido principal</a>
    <div style={{ display: "flex", minHeight: "100vh", background: colors.g1, fontFamily: "-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif", color: colors.nv }}>
      <SB aA={aA} aD={aD} onAC={hAC} onDC={hDC} col={sbCol} onCol={() => sSbCol(!sbCol)} isPersonal={isPersonal} mob={mob} sbOpen={sbOpen} onClose={() => sSbOpen(false)} vw={vw} onNav={(v: string) => { sVw(v); scrollTop(); }} user={user} />
      <div style={{ flex: 1, display: "flex", flexDirection: "column" as const, minWidth: 0 }}>
        <AppHeader user={user} mob={mob} isDark={isDark} nav={nav} vw={vw} sVw={sVw} scrollTop={scrollTop} sAA={sAA} sAD={sAD} sKpiFilt={sKpiFilt} sSbOpen={sSbOpen} search={searchTerm} sSr={sSr} gsOpen={gsOpen} sGsOpen={sGsOpen} gsRef={gsRef} gsResults={gsResults} sSl={sSl} badgeCount={badgeCount} shNot={shNot} sShNot={sShNot} notifFilter={notifFilter} sNotifFilter={sNotifFilter} notifPage={notifPage} sNotifPage={sNotifPage} refreshNotifs={refreshNotifs} toggleTheme={toggleTheme} sShowPw={sShowPw} logout={logout} offlineState={offlineState} onSync={async () => { const r = await sync(); if (r.processed > 0) showT(r.processed + " cambio" + (r.processed > 1 ? "s" : "") + " sincronizado" + (r.processed > 1 ? "s" : "")); }} headerBg={headerBg} />
        <main id="main-content" ref={mainRef} style={{ flex: 1, padding: mob ? "12px 8px" : "20px 16px", overflowY: "auto" as const, marginTop: 4 }}>
          {dataLoading ? <div style={{ display: "flex", flexDirection: "column" as const, gap: 12, padding: 16 }}>{[1, 2, 3, 4].map(i => <div key={i} style={{ background: cardBg, borderRadius: 14, padding: 18, border: "1px solid " + colors.g2 }}><div style={{ height: 12, width: i % 2 ? "60%" : "40%", background: colors.g2, borderRadius: 6, marginBottom: 10 }} /><div style={{ height: 8, width: "80%", background: colors.g2, borderRadius: 4, marginBottom: 6 }} /><div style={{ height: 8, width: "50%", background: colors.g2, borderRadius: 4 }} /></div>)}</div> : <>
          {vw === "my" && isPersonal && <MyDash user={user} onSel={(p: any) => sSl(p)} mob={mob} search={searchTerm}
            onUpdDist={async (id: number, d: any) => { try { sInvDist(prev => prev.map(x => x.id === id ? { ...x, ...d } : x)); await supabase.from("inventory_distributions").update(d).eq("id", id); showT("Actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onNotifyAdmin={(title: string, msg: string) => { const admins = users.filter((u: any) => u.role === "admin" || u.role === "superadmin" || u.role === "coordinador"); admins.forEach((a: any) => sendNotif(a.id, title, msg, "info")); }}
          />}
          {vw === "tasks" && !isPersonal && (() => { const myPeds = isAd ? peds : user.role === "coordinador" ? peds.filter((p: any) => p.dId === user.dId || p.cId === user.id || p.asTo === user.id) : user.role === "embudo" ? peds.filter((p: any) => p.rG || p.st === ST.E || p.cId === user.id || p.asTo === user.id) : peds.filter((p: any) => p.cId === user.id || p.asTo === user.id); const tot = myPeds.length, pe = myPeds.filter((p: any) => p.st === ST.P).length, cu = myPeds.filter((p: any) => [ST.C, ST.E, ST.V].indexOf(p.st) >= 0).length, ok = myPeds.filter((p: any) => p.st === ST.OK).length; const pePct = tot ? Math.round(pe / tot * 100) : 0, cuPct = tot ? Math.round(cu / tot * 100) : 0, okPct = tot ? Math.round(ok / tot * 100) : 0; return <div>
            <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 16 }}><div><h2 style={{ margin: 0, fontSize: mob ? 16 : 19, color: colors.nv, fontWeight: 800 }}>üìã {isAd ? "Todas las tareas" : "Mis tareas"}</h2><p style={{ margin: 0, fontSize: 11, color: colors.g4 }}>{tot} tareas</p></div><Btn v="p" s="s" onClick={() => sVw("new")}>+ Tarea</Btn></div>
            <div style={{ display: "flex", justifyContent: "center", gap: mob ? 24 : 40, marginBottom: 20 }}>
              <div style={{ textAlign: "center" as const }}><Ring pct={pePct} color={colors.rd} size={mob ? 70 : 80} /><div style={{ fontSize: 11, fontWeight: 700, color: colors.rd, marginTop: 4 }}>Pendientes</div><div style={{ fontSize: 13, fontWeight: 800, color: colors.nv }}>{pe}</div></div>
              <div style={{ textAlign: "center" as const }}><Ring pct={cuPct} color={colors.yl} size={mob ? 70 : 80} /><div style={{ fontSize: 11, fontWeight: 700, color: colors.yl, marginTop: 4 }}>En curso</div><div style={{ fontSize: 13, fontWeight: 800, color: colors.nv }}>{cu}</div></div>
              <div style={{ textAlign: "center" as const }}><Ring pct={okPct} color={colors.gn} size={mob ? 70 : 80} /><div style={{ fontSize: 11, fontWeight: 700, color: colors.gn, marginTop: 4 }}>Completadas</div><div style={{ fontSize: 13, fontWeight: 800, color: colors.nv }}>{ok}</div></div>
            </div>
            <TList title="Tareas" icon="üìã" color={T.nv} peds={myPeds} onSel={(p: any) => sSl(p)} search={searchTerm} mob={mob} onBulk={handleBulk} onImport={handleImport} user={user} />
          </div>; })()}
          {vw === "kanban" && !isPersonal && <KanbanView user={user} onSel={(p: any) => sSl(p)} mob={mob} onStatusChange={async (id: number, newSt: string) => { try { sPd(p => p.map(x => x.id === id ? { ...x, st: newSt } : x)); await supabase.from("tasks").update({ status: newSt }).eq("id", id); addLog(id, user.id, fn(user), "Cambi√≥ estado a " + (SC[newSt]?.l || newSt), "sys"); const p2 = peds.find(x => x.id === id); if (p2?.asTo && p2.asTo !== user.id) sendNotif(p2.asTo, "Tarea #" + id + " ‚Üí " + (SC[newSt]?.l || newSt), (p2.tit || p2.desc || "").slice(0, 60), "task"); if (p2?.cId && p2.cId !== user.id && p2.cId !== p2.asTo) sendNotif(p2.cId, "Tarea #" + id + " ‚Üí " + (SC[newSt]?.l || newSt), (p2.tit || p2.desc || "").slice(0, 60), "task"); showT("Estado actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); } }} />}
          {vw === "feed" && !isPersonal && <ActivityFeed onSel={(p: any) => sSl(p)} mob={mob} />}
          {vw === "comm" && (isAd || user.role === "coordinador") && <CommView user={user} mob={mob} />}
          {vw === "recurrentes" && (isAd || user.role === "coordinador") && <RecurrentTasks user={user} mob={mob}
            onAdd={async (d: any) => { try { const { data, error } = await supabase.from("task_templates").insert(d).select().single(); if (error) throw new Error(error.message); if (data) sTaskTemplates(prev => [data, ...prev]); showT("Template creado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onUpd={async (id: number, d: any) => { try { sTaskTemplates(prev => prev.map(t => t.id === id ? { ...t, ...d } : t)); await supabase.from("task_templates").update(d).eq("id", id); showT("Template actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDel={async (id: number) => { try { sTaskTemplates(prev => prev.filter(t => t.id !== id)); await supabase.from("task_templates").delete().eq("id", id); showT("Template eliminado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
          />}
          {vw === "inventario" && (isAd || user.role === "coordinador") && <InventarioView user={user} mob={mob}
            onAdd={async (d: any) => { try { const { data, error } = await supabase.from("inventory").insert(d).select().single(); if (error) throw new Error(error.message); if (data) sInventory(prev => [data, ...prev]); showT("Item agregado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onUpd={async (id: number, d: any) => { try { sInventory(prev => prev.map(x => x.id === id ? { ...x, ...d } : x)); await supabase.from("inventory").update(d).eq("id", id); showT("Item actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDel={async (id: number) => { try { sInventory(prev => prev.filter(x => x.id !== id)); await supabase.from("inventory").delete().eq("id", id); showT("Item eliminado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onBulkAdd={async (rows: any[]) => { try { const { data, error } = await supabase.from("inventory").insert(rows).select(); if (error) throw new Error(error.message); if (data) sInventory(prev => [...data, ...prev]); showT(data?.length + " items importados"); } catch (e: any) { showT(e.message || "Error al importar", "err"); } }}
            onAddMaint={async (d: any) => { try { const { data, error } = await supabase.from("inventory_maintenance").insert(d).select().single(); if (error) throw new Error(error.message); if (data) sInvMaint(prev => [data, ...prev]); if (d.next_due) { await supabase.from("inventory").update({ next_maint_date: d.next_due }).eq("id", d.inventory_id); sInventory(prev => prev.map(x => x.id === d.inventory_id ? { ...x, next_maint_date: d.next_due } : x)); } showT("Mantenimiento registrado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onUpdMaint={async (id: number, d: any) => { try { sInvMaint(prev => prev.map(x => x.id === id ? { ...x, ...d } : x)); await supabase.from("inventory_maintenance").update(d).eq("id", id); showT("Mantenimiento actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDelMaint={async (id: number) => { try { sInvMaint(prev => prev.filter(x => x.id !== id)); await supabase.from("inventory_maintenance").delete().eq("id", id); showT("Registro eliminado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onAddDist={async (d: any) => { try { const { data, error } = await supabase.from("inventory_distributions").insert(d).select().single(); if (error) throw new Error(error.message); if (data) sInvDist(prev => [data, ...prev]); showT("Distribuci√≥n registrada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onUpdDist={async (id: number, d: any) => { try { sInvDist(prev => prev.map(x => x.id === id ? { ...x, ...d } : x)); await supabase.from("inventory_distributions").update(d).eq("id", id); showT("Distribuci√≥n actualizada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDelDist={async (id: number) => { try { sInvDist(prev => prev.filter(x => x.id !== id)); await supabase.from("inventory_distributions").delete().eq("id", id); showT("Distribuci√≥n eliminada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
          />}
          {vw === "reservas" && <ReservasView user={user} mob={mob}
            onAdd={async (d: any) => { try { const items = Array.isArray(d) ? d : [d]; const { data, error } = await supabase.from("bookings").insert(items).select(); if (error) throw new Error(error.message); if (data) sBookings(prev => [...data, ...prev]); showT(items.length > 1 ? `${items.length} espacios reservados` : "Espacio reservado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onUpd={async (id: number, d: any) => { try { sBookings(prev => prev.map(x => x.id === id ? { ...x, ...d } : x)); await supabase.from("bookings").update(d).eq("id", id); showT("Espacio actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDel={async (id: number) => { try { sBookings(prev => prev.filter(x => x.id !== Number(id))); await supabase.from("bookings").delete().eq("id", id); showT("Espacio eliminado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDelMulti={async (ids: string[]) => { try { const numIds = ids.map(Number); sBookings(prev => prev.filter(x => !numIds.includes(x.id))); await supabase.from("bookings").delete().in("id", numIds); showT(`${ids.length} espacios eliminados`); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onUpdMulti={async (ids: string[], d: any) => { try { const numIds = ids.map(Number); sBookings(prev => prev.map(x => numIds.includes(x.id) ? { ...x, ...d } : x)); await supabase.from("bookings").update(d).in("id", numIds); showT(`${ids.length} espacios actualizados`); } catch (e: any) { showT(e.message || "Error", "err"); } }}
          />}
          {vw === "sponsors" && (isAd || user.role === "coordinador" || user.role === "embudo") && <SponsorsView user={user} mob={mob} canjeUsado={canjeUsado} sponMsgs={sponMsgs} sponDeliveries={sponDeliveries}
            onAdd={async (d: any) => { const row = { ...d, created_by: user.id, created_by_name: fn(user) }; const { data, error } = await supabase.from("sponsors").insert(row).select().single(); if (error) throw new Error(error.message); if (data) { sSponsors(prev => [data, ...prev]); showT("Sponsor agregado"); } }}
            onUpd={async (id: number, d: any) => { try { sSponsors(prev => prev.map(x => x.id === id ? { ...x, ...d } : x)); await supabase.from("sponsors").update(d).eq("id", id); showT("Sponsor actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDel={async (id: number) => { try { sSponsors(prev => prev.filter(x => x.id !== id)); await supabase.from("sponsors").delete().eq("id", id); showT("Sponsor eliminado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onSponMsg={async (sponsorId: number, txt: string) => { try { const safe = sanitize(txt); if (!safe) return; const ts = new Date().toISOString(); const opt = { id: Date.now(), sponsor_id: sponsorId, user_id: user.id, user_name: fn(user), content: safe, type: "msg", created_at: ts }; sSponMsgs(p => [...p, opt]); await supabase.from("sponsor_messages").insert({ sponsor_id: sponsorId, user_id: user.id, user_name: fn(user), content: safe, type: "msg" }); const mentionRx = /@([\w\s]+?)(?=\s@|$)/g; let match; while ((match = mentionRx.exec(safe)) !== null) { const mName = match[1].trim(); const mUser = users.find((u: any) => (fn(u)).toLowerCase() === mName.toLowerCase()); if (mUser && mUser.id !== user.id) { sendNotif(mUser.id, "Te mencionaron en sponsor", safe.slice(0, 80), "info"); } } } catch { showT("Error al enviar mensaje", "err"); } }}
            onAddDelivery={async (d: any) => { try { const total = Number(d.quantity || 1) * Number(d.unit_value || 0); const row = { ...d, total_value: total }; const { data, error } = await supabase.from("sponsor_deliveries").insert(row).select().single(); if (error) throw new Error(error.message); if (!data) return; sSponDeliveries(prev => [data, ...prev]); if (d.destination === "division" || d.destination === "venta") { const sp = sponsors.find((s: any) => s.id === d.sponsor_id); const invRow = { name: d.description, category: "Material Deportivo", item_type: "lote", quantity: d.quantity || 1, condition: "bueno", location: "Club", notes: "Entrega sponsor: " + (sp?.name || ""), created_by: user.id, created_by_name: fn(user) }; const { data: invData } = await supabase.from("inventory").insert(invRow).select().single(); if (invData) { sInventory(prev => [invData, ...prev]); await supabase.from("sponsor_deliveries").update({ inventory_id: invData.id }).eq("id", data.id); sSponDeliveries(prev => prev.map(x => x.id === data.id ? { ...x, inventory_id: invData.id } : x)); if (d.destination === "division" && d.division) { const distRow = { inventory_id: invData.id, division: d.division, qty_given: d.quantity || 1, distributed_by: user.id, distributed_by_name: fn(user), notes: "Auto: entrega sponsor " + (sp?.name || "") }; const { data: distData } = await supabase.from("inventory_distributions").insert(distRow).select().single(); if (distData) sInvDist(prev => [distData, ...prev]); } } } showT("Entrega registrada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onUpdDelivery={async (id: number, d: any) => { try { sSponDeliveries(prev => prev.map(x => x.id === id ? { ...x, ...d } : x)); await supabase.from("sponsor_deliveries").update(d).eq("id", id); } catch (e: any) { showT(e.message || "Error", "err"); } }}
          />}
          {vw === "archivos" && !isPersonal && <ArchivosView user={user} mob={mob} showT={showT} />}
          {vw === "proyectos" && !isPersonal && <ProyectosView user={user} mob={mob} filteredProjects={projects}
            onAddProject={async (p: any) => { try { const row = { name: p.name, description: p.description || "", created_by: user.id, created_by_name: fn(user), status: p.status || "borrador" }; const { data, error } = await supabase.from("projects").insert(row).select().single(); if (error) throw new Error(error.message); if (data) sProjects(prev => [data, ...prev]); showT(p.status === "enviado" ? "Proyecto enviado" : "Borrador guardado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onUpdProject={async (id: number, d: any) => { try { sProjects(prev => prev.map(p => p.id === id ? { ...p, ...d } : p)); await supabase.from("projects").update(d).eq("id", id); showT("Proyecto actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDelProject={async (id: number) => { try { sProjects(prev => prev.filter(p => p.id !== id)); sProjTasks(prev => prev.filter((t: any) => t.project_id !== id)); await supabase.from("projects").delete().eq("id", id); showT("Proyecto eliminado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onAddTask={async (t: any) => { try { const { data, error } = await supabase.from("project_tasks").insert(t).select().single(); if (error) throw new Error(error.message); if (data) sProjTasks(prev => [data, ...prev]); showT("Tarea creada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onUpdTask={async (id: number, d: any) => { try { sProjTasks(prev => prev.map((t: any) => t.id === id ? { ...t, ...d } : t)); await supabase.from("project_tasks").update(d).eq("id", id); showT("Tarea actualizada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDelTask={async (id: number) => { try { sProjTasks(prev => prev.filter((t: any) => t.id !== id)); await supabase.from("project_tasks").delete().eq("id", id); showT("Tarea eliminada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onAddBudget={async (b: any) => { try { const { data, error } = await supabase.from("project_budgets").insert(b).select().single(); if (error) throw new Error(error.message); if (data) sProjBudgets(prev => [data, ...prev]); showT("Presupuesto agregado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onUpdBudget={async (id: number, d: any) => { try { sProjBudgets(prev => prev.map(b => b.id === id ? { ...b, ...d } : b)); await supabase.from("project_budgets").update(d).eq("id", id); showT("Presupuesto actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDelBudget={async (id: number) => { try { sProjBudgets(prev => prev.filter(b => b.id !== id)); await supabase.from("project_budgets").delete().eq("id", id); showT("Presupuesto eliminado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
          />}
          {vw === "org" && <Org areas={areas} deptos={deptos} users={users} om={om} pedidos={peds} onSel={(p: any) => sSl(p)} onEditSave={async (id: string, d: any) => { sOm(p => p.map(m => m.id === id ? { ...m, ...d } : m)); await supabase.from("org_members").update({ first_name: d.n, last_name: d.a, email: d.mail || "", phone: d.tel || "" }).eq("id", id); }} onDelOm={async (id: string) => { sOm(p => p.filter(m => m.id !== id)); await supabase.from("org_members").delete().eq("id", id); }} onDelUser={async (id: string) => { sUs(p => p.filter(u => u.id !== id)); await supabase.from("profiles").delete().eq("id", id); }} onEditUser={() => { sVw("profs"); }} isSA={isSA} onAssignTask={(u: any) => { sPreAT(u); sVw("new"); }} mob={mob}
            onReorderOm={async (id: string, dir: string, type: string) => { const grp = om.filter((m: any) => m.t === type).sort((a: any, b: any) => (a.so || 0) - (b.so || 0)); const idx = grp.findIndex((m: any) => m.id === id); const si = dir === "up" ? idx - 1 : idx + 1; if (si < 0 || si >= grp.length) return; [grp[idx], grp[si]] = [grp[si], grp[idx]]; const upd: any = {}; grp.forEach((m: any, i: number) => { upd[m.id] = i; }); sOm(prev => prev.map((m: any) => upd[m.id] !== undefined ? { ...m, so: upd[m.id] } : m)); for (const m of grp) { await supabase.from("org_members").update({ sort_order: upd[m.id] }).eq("id", m.id); } }}
            onReorderUser={async (uid: string, dir: string, dId: number) => { const grp = users.filter((u: any) => u.dId === dId).sort((a: any, b: any) => (a.so || 0) - (b.so || 0)); const idx = grp.findIndex((u: any) => u.id === uid); const si = dir === "up" ? idx - 1 : idx + 1; if (si < 0 || si >= grp.length) return; [grp[idx], grp[si]] = [grp[si], grp[idx]]; const upd: any = {}; grp.forEach((u: any, i: number) => { upd[u.id] = i; }); sUs(prev => prev.map((u: any) => upd[u.id] !== undefined ? { ...u, so: upd[u.id] } : u)); for (const u of grp) { await supabase.from("profiles").update({ sort_order: upd[u.id] }).eq("id", u.id); } }}
          />}
          {vw === "cal" && <CalView user={user} onSel={(p: any) => sSl(p)} mob={mob} onNav={(v: string) => sVw(v)}
            onDateChange={async (id: number, newDate: string) => { try { sPd(p => p.map(x => x.id === id ? { ...x, fReq: newDate } : x)); await supabase.from("tasks").update({ due_date: newDate }).eq("id", id); addLog(id, user.id, fn(user), "Cambi√≥ fecha l√≠mite a " + newDate.split("-").reverse().join("/"), "sys"); showT("Fecha actualizada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onAddReminder={async (r: any) => { try { const row: any = { user_id: user.id, user_name: fn(user), title: r.title, date: r.date, description: r.description || "", color: r.color || "#3B82F6", recurrence: r.recurrence || "none", assigned_to: r.assigned_to || null, assigned_name: r.assigned_name || "" }; const { data, error } = await supabase.from("reminders").insert(row).select().single(); if (error) throw new Error(error.message); sRems(p => [...(data ? [data] : []), ...p]); showT("Recordatorio creado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDelReminder={async (id: number) => { try { sRems(p => p.filter(x => x.id !== id)); await supabase.from("reminders").delete().eq("id", id); showT("Recordatorio eliminado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
          />}
          {vw === "presu" && (isAd || user.role === "coordinador" || user.role === "embudo") && <div>{prevVw === "cal" && <button onClick={() => sVw("cal")} style={{ display: "inline-flex", alignItems: "center", gap: 4, padding: "5px 12px", borderRadius: 8, border: "1px solid " + colors.g3, background: colors.g1, color: colors.nv, fontSize: 11, fontWeight: 600, cursor: "pointer", marginBottom: 10 }}>‚Üê Volver al Calendario</button>}<PresView user={user} mob={mob} onSel={(p: any) => sSl(p)}
            onAddPresu={async (d: any) => { try { const row = presuToDB(d); const { data, error } = await supabase.from("presupuestos").insert(row).select().single(); if (error) throw new Error(error.message); sPr(p => [presuFromDB(data), ...p]); showT("Presupuesto agregado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onUpdPresu={async (id: number, d: any) => { try { const prev = presu.find(x => x.id === id); sPr(p => p.map(x => x.id === id ? { ...x, ...d } : x)); await supabase.from("presupuestos").update(d).eq("id", id); if (d.status && prev && d.status !== prev.status && prev.solicitado_por) { const stLabel = d.status === "aprobado" ? "aprobado" : d.status === "rechazado" ? "rechazado" : d.status === "recibido" ? "recibido" : "actualizado"; const reqUser = users.find((u: any) => fn(u) === prev.solicitado_por || u.id === prev.solicitado_por); if (reqUser && reqUser.id !== user.id) sendNotif(reqUser.id, "Presupuesto " + stLabel, prev.descripcion?.slice(0, 60) || "", "budget"); } showT("Presupuesto actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDelPresu={async (id: number) => { try { sPr(p => p.filter(x => x.id !== id)); await supabase.from("presupuestos").delete().eq("id", id); showT("Presupuesto eliminado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onAddProv={async (d: any) => { try { const { data, error } = await supabase.from("proveedores").insert(d).select().single(); if (error) throw new Error(error.message); sPv(p => [provFromDB(data), ...p]); showT("Proveedor agregado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
          /></div>}
          {vw === "reun" && (isAd || user.role === "coordinador") && <div>{prevVw === "cal" && <button onClick={() => sVw("cal")} style={{ display: "inline-flex", alignItems: "center", gap: 4, padding: "5px 12px", borderRadius: 8, border: "1px solid " + colors.g3, background: colors.g1, color: colors.nv, fontSize: 11, fontWeight: 600, cursor: "pointer", marginBottom: 10 }}>‚Üê Volver al Calendario</button>}<Reuniones user={user} mob={mob}
            onAddAg={async (a: any) => { try { const { data, error } = await supabase.from("agendas").insert({ type: a.type, area_name: a.areaName || null, date: a.date, sections: a.sections, presentes: a.presentes || [], status: a.status, created_at: a.createdAt || TODAY }).select().single(); if (error) throw new Error(error.message); const nid = data?.id || 0; sAgs(p => [{ ...a, id: nid }, ...p]); showT(a.status === "enviada" ? "OD enviada y minuta creada" : "OD guardada"); return nid; } catch (e: any) { showT(e.message || "Error al guardar OD", "err"); return 0; } }}
            onUpdAg={async (id: number, d: any) => { try { sAgs(p => p.map(a => a.id === id ? { ...a, ...d, areaName: d.area_name !== undefined ? d.area_name : a.areaName } : a)); const dbUpd: any = {}; if (d.status) dbUpd.status = d.status; if (d.sections) dbUpd.sections = d.sections; if (d.presentes) dbUpd.presentes = d.presentes; if (d.date) dbUpd.date = d.date; if (d.area_name !== undefined) dbUpd.area_name = d.area_name; await supabase.from("agendas").update(dbUpd).eq("id", id); showT("OD actualizada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDelAg={async (id: number) => { try { sAgs(p => p.filter(a => a.id !== id)); await supabase.from("agendas").delete().eq("id", id); showT("OD eliminada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onAddMin={async (m: any) => { try { const { data } = await supabase.from("minutas").insert({ type: m.type, area_name: m.areaName || null, agenda_id: m.agendaId || null, date: m.date, hora_inicio: m.horaInicio, hora_cierre: m.horaCierre, lugar: m.lugar, presentes: m.presentes, ausentes: m.ausentes, sections: m.sections, tareas: m.tareas, status: m.status, created_at: m.createdAt || TODAY }).select().single(); if (data) sMins(p => [{ ...m, id: data.id }, ...p]); else sMins(p => [m, ...p]); showT(m.status === "final" ? "Minuta finalizada" : "Minuta guardada"); } catch (e: any) { showT(e.message || "Error al guardar minuta", "err"); } }}
            onUpdMin={async (id: number, d: any) => { try { sMins(p => p.map(m => m.id === id ? { ...m, ...d } : m)); const upd: any = {}; if (d.status) upd.status = d.status; if (d.sections) upd.sections = d.sections; if (d.tareas) upd.tareas = d.tareas; if (d.presentes) upd.presentes = d.presentes; if (d.ausentes) upd.ausentes = d.ausentes; if (d.date) upd.date = d.date; if (d.hora_inicio !== undefined) upd.hora_inicio = d.hora_inicio; if (d.hora_cierre !== undefined) upd.hora_cierre = d.hora_cierre; if (d.lugar !== undefined) upd.lugar = d.lugar; await supabase.from("minutas").update(upd).eq("id", id); showT("Minuta actualizada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onDelMin={async (id: number) => { try { sMins(p => p.filter(m => m.id !== id)); await supabase.from("minutas").delete().eq("id", id); showT("Minuta eliminada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
            onCreateTasks={async (tareas: any[]) => { try { const ts = TODAY + " " + new Date().toTimeString().slice(0, 5); const newTasks: any[] = []; for (const t of tareas) { const resp = users.find((u: any) => u.id === t.respId); const row: any = { division: "", creator_id: user.id, creator_name: fn(user), dept_id: resp?.dId || 1, tipo: "Administrativo", description: t.desc, due_date: t.fecha || "", urgency: "Normal", status: "curso", assigned_to: t.respId || null, requires_expense: false, expense_ok: null, resolution: "", created_at: TODAY, amount: null }; const { data } = await supabase.from("tasks").insert(row).select().single(); const tid = data?.id || 0; if (tid) { await supabase.from("task_messages").insert([{ task_id: tid, user_id: user.id, user_name: fn(user), content: "Cre√≥ tarea desde minuta", type: "sys" }, { task_id: tid, user_id: user.id, user_name: fn(user), content: "Asign√≥ a " + (resp ? fn(resp) : ""), type: "sys" }]); newTasks.push({ id: tid, div: "", cId: user.id, cN: fn(user), dId: resp?.dId || 1, tipo: "Administrativo", desc: t.desc, fReq: t.fecha || "", urg: "Normal", st: ST.C, asTo: t.respId, rG: false, eOk: null, resp: "", cAt: TODAY, monto: null, log: [{ dt: ts, uid: user.id, by: fn(user), act: "Cre√≥ tarea desde minuta", t: "sys" }, { dt: ts, uid: user.id, by: fn(user), act: "Asign√≥ a " + (resp ? fn(resp) : ""), t: "sys" }] }); } } sPd(p => [...newTasks, ...p]); showT(newTasks.length + " tarea(s) creada(s)"); } catch (e: any) { showT(e.message || "Error al crear tareas", "err"); } }}
          /></div>}
          {vw === "profs" && <Profs onDel={async (id: string) => { try { sUs(p => p.filter(u => u.id !== id)); await supabase.from("profiles").delete().eq("id", id); showT("Perfil eliminado"); } catch (e: any) { showT(e.message || "Error", "err"); } }} onAdd={async (u: any) => {
            try { const { data: { session } } = await supabase.auth.getSession(); const tok = session?.access_token;
            if (!tok || !u.mail) { sUs(p => [...p, u]); showT("Perfil creado (sin cuenta auth)"); return; }
            const res = await fetch("/api/admin/create-user", { method: "POST", headers: { "Content-Type": "application/json", "Authorization": "Bearer " + tok }, body: JSON.stringify({ email: u.mail, first_name: u.n, last_name: u.a, role: u.role, dept_id: u.dId, division: u.div, phone: u.tel }) });
            const json = await res.json(); if (json.error) { showT(json.error, "err"); return; } if (json.user) { sUs(p => [...p, { ...u, id: json.user.id }]); showT("Usuario creado correctamente"); } else { sUs(p => [...p, u]); showT("Perfil creado"); }
            } catch (e: any) { showT(e.message || "Error al crear usuario", "err"); }
          }} onEditUser={async (id: string, d: any) => {
            try { sUs(p => p.map(u => u.id === id ? { ...u, ...d } : u)); await supabase.from("profiles").update({ first_name: d.n, last_name: d.a, role: d.role, dept_id: d.dId, division: d.div, email: d.mail || "", phone: d.tel || "" }).eq("id", id);
            if (d.mail) { const oldUser = users.find(u => u.id === id); if (oldUser && d.mail !== oldUser.mail) { const { data: { session } } = await supabase.auth.getSession(); const tok = session?.access_token; if (tok) await fetch("/api/admin/create-user", { method: "PUT", headers: { "Content-Type": "application/json", "Authorization": "Bearer " + tok }, body: JSON.stringify({ userId: id, email: d.mail }) }); } }
            showT("Perfil actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); }
          }} isAd={isAd} onAssignTask={(u: any) => { sPreAT(u); sVw("new"); }} mob={mob} />}
          {vw === "new" && !preAT && <Card style={{ maxWidth: mob ? undefined : 480, textAlign: "center" as const }}>
            <h2 style={{ margin: "0 0 16px", fontSize: mob ? 15 : 17, color: colors.nv, fontWeight: 800 }}>¬øQu√© quer√©s crear?</h2>
            <div style={{ display: "flex", gap: 12, justifyContent: "center", flexWrap: "wrap" as const }}>
              <div onClick={() => sVw("new-task")} style={{ flex: 1, minWidth: 160, padding: mob ? 20 : 24, background: colors.nv + "08", border: "2px solid " + colors.nv, borderRadius: 14, cursor: "pointer", textAlign: "center" as const }}><div style={{ fontSize: 28, marginBottom: 8 }}>üèâ</div><div style={{ fontSize: 14, fontWeight: 700, color: colors.nv }}>+ Nueva Tarea</div><div style={{ fontSize: 11, color: colors.g4, marginTop: 4 }}>Log√≠stica, infraestructura, administrativo, etc.</div></div>
              <div onClick={() => sVw("comm-req")} style={{ flex: 1, minWidth: 160, padding: mob ? 20 : 24, background: "#8B5CF608", border: "2px solid #8B5CF6", borderRadius: 14, cursor: "pointer", textAlign: "center" as const }}><div style={{ fontSize: 28, marginBottom: 8 }}>üì£</div><div style={{ fontSize: 14, fontWeight: 700, color: "#8B5CF6" }}>+ Comunicaci√≥n</div><div style={{ fontSize: 11, color: colors.g4, marginTop: 4 }}>Pedir flyer, post, video, placa al depto de Comunicaci√≥n</div></div>
              <div onClick={() => sVw("new-factura")} style={{ flex: 1, minWidth: 160, padding: mob ? 20 : 24, background: "#05966908", border: "2px solid #059669", borderRadius: 14, cursor: "pointer", textAlign: "center" as const }}><div style={{ fontSize: 28, marginBottom: 8 }}>üßæ</div><div style={{ fontSize: 14, fontWeight: 700, color: "#059669" }}>+ Factura</div><div style={{ fontSize: 11, color: colors.g4, marginTop: 4 }}>Cargar factura o remito con proveedor y monto</div></div>
            </div>
            <div style={{ marginTop: 16 }}><Btn v="g" onClick={() => sVw(isPersonal ? "my" : "tasks")}>‚Üê Volver</Btn></div>
          </Card>}
          {(vw === "new-task" || (vw === "new" && preAT)) && <NP user={user} preAssign={preAT} mob={mob} canjeUsado={canjeUsado} onSub={async (p: any) => {
            try { const row: any = taskToDB(p); const { data, error } = await supabase.from("tasks").insert(row).select().single(); if (error) throw new Error(error.message); const tid = data?.id || p.id; const localP = { ...p, id: tid }; sPd(ps => [localP, ...ps]); for (const l of (p.log || [])) { await supabase.from("task_messages").insert({ task_id: tid, user_id: l.uid, user_name: l.by, content: l.act, type: l.t }); } if (localP.asTo && localP.asTo !== user.id) { sendNotif(localP.asTo, "Nueva tarea asignada #" + tid, (localP.tit || localP.desc || "").slice(0, 80), "task", "", true); } if (p._presu && tid) { const prRow = presuToDB({ ...p._presu, task_id: tid, status: PST.SOL, solicitado_por: fn(user), solicitado_at: TODAY }); const { data: prData } = await supabase.from("presupuestos").insert(prRow).select().single(); if (prData) sPr(prev => [presuFromDB(prData), ...prev]); } sPreAT(null); sVw(isPersonal ? "my" : "tasks"); sAA(null); sAD(null); showT(p._presu ? (p._presu.is_canje ? "Tarea creada con canje" : "Tarea creada con presupuesto") : "Tarea creada"); } catch (e: any) { showT(e.message || "Error al crear tarea", "err"); }
          }} onX={() => { sPreAT(null); sVw(preAT ? (isPersonal ? "my" : "tasks") : "new"); }} />}
          {vw === "comm-req" && <CommReq user={user} mob={mob} onSub={async (p: any) => {
            try { const row: any = taskToDB(p); const { data, error } = await supabase.from("tasks").insert(row).select().single(); if (error) throw new Error(error.message); const tid = data?.id || p.id; const localP = { ...p, id: tid }; sPd(ps => [localP, ...ps]); for (const l of (p.log || [])) { await supabase.from("task_messages").insert({ task_id: tid, user_id: l.uid, user_name: l.by, content: l.act, type: l.t }); } sVw(isPersonal ? "my" : "tasks"); showT("Pedido de comunicaci√≥n creado"); } catch (e: any) { showT(e.message || "Error al crear pedido", "err"); }
          }} onX={() => sVw("new")} />}
          {vw === "new-factura" && <NewFactura user={user} mob={mob} onSub={async (d: any) => {
            try {
              // Update the archivos record created by upload with factura metadata
              const { data: existing } = await supabase.from("archivos").select("id").eq("url", d.fileUrl).maybeSingle();
              if (existing) {
                const upd = { titulo: d.titulo, proveedor: d.proveedor, monto: d.monto, moneda: d.moneda, nro_factura: d.nro_factura || null, fecha_factura: d.fecha_factura || null, notas: d.notas || null };
                await supabase.from("archivos").update(upd).eq("id", existing.id);
                sArchivos(prev => prev.map((a: any) => a.id === existing.id ? { ...a, ...upd } : a));
              } else {
                // Fallback: insert new record if upload didn't auto-create one
                const row = { titulo: d.titulo, name: d.fileName, url: d.fileUrl, folder: "facturas", category: "factura", mime_type: d.mimeType, size_bytes: d.fileSize, uploaded_by: user.id, proveedor: d.proveedor, monto: d.monto, moneda: d.moneda, nro_factura: d.nro_factura || null, fecha_factura: d.fecha_factura || null, notas: d.notas || null };
                const { data } = await supabase.from("archivos").insert(row).select().single();
                if (data) sArchivos(prev => [data, ...prev]);
              }
              sVw("archivos"); showT("Factura guardada");
            } catch (e: any) { showT(e.message || "Error al guardar factura", "err"); }
          }} onX={() => sVw("new")} />}
          {vw === "proy" && <Proyecto setHitos={(updater: any) => { sHi((prev: any) => { const next = typeof updater === "function" ? updater(prev) : updater; next.forEach((h: any) => { supabase.from("milestones").update({ pct: h.pct }).eq("id", h.id); }); return next; }); }} isAd={isAd} mob={mob} />}
          {vw === "dash" && !isPersonal && !aA && !aD && !kpiFilt && <CustomDash user={user} mob={mob} onSel={(p: any) => sSl(p)} onFilter={(k: string) => sKpiFilt(k)} onAC={hAC} isSA={isSA} onNav={(view: string, filt?: string) => { if (view === "filter" && filt) { sKpiFilt(filt); } else { sVw(view); } }}
            onExportWeekly={() => { const today = new Date(); const weekAgo = new Date(today.getTime() - 7 * 86400000); const fmtD2 = (d: Date) => d.toISOString().slice(0, 10); const range = fmtD2(weekAgo) + " al " + fmtD2(today); const ok = peds.filter((p: any) => p.st === ST.OK); const pend = peds.filter((p: any) => p.st === ST.P); const od = peds.filter((p: any) => p.st !== ST.OK && isOD(p.fReq)); const approvedPr = presu.filter((pr: any) => pr.status === "aprobado"); const pendPr = presu.filter((pr: any) => pr.status !== "aprobado" && pr.status !== "rechazado"); const topAreas = areas.map((a: any) => { const dIds = deptos.filter((d: any) => d.aId === a.id).map((d: any) => d.id); const aP = peds.filter((p: any) => dIds.indexOf(p.dId) >= 0); const aOk = aP.filter((p: any) => p.st === ST.OK).length; return { name: a.name, total: aP.length, completed: aOk, pct: aP.length ? Math.round(aOk / aP.length * 100) : 0 }; }).filter((a: any) => a.total > 0); exportReportPDF({ period: "Semanal", dateRange: range, stats: [{ label: "Total tareas", value: String(peds.length), color: "#0A1628" }, { label: "Completadas", value: String(ok.length), color: "#10B981" }, { label: "Pendientes", value: String(pend.length), color: "#DC2626" }, { label: "Vencidas", value: String(od.length), color: "#7C3AED" }], tasksByStatus: Object.keys(SC).map(k => ({ status: SC[k].l, icon: SC[k].i, count: peds.filter((p: any) => p.st === k).length, color: SC[k].c })), completedTasks: ok.slice(0, 20).map((p: any) => { const ag = users.find((u: any) => u.id === p.asTo); return { id: p.id, desc: p.desc, assignee: ag ? fn(ag) : "‚Äì", date: p.fReq }; }), pendingTasks: [...od, ...pend].slice(0, 20).map((p: any) => { const ag = users.find((u: any) => u.id === p.asTo); return { id: p.id, desc: p.desc, assignee: ag ? fn(ag) : "‚Äì", date: p.fReq, overdue: p.st !== ST.OK && isOD(p.fReq) }; }), budgetSummary: { total: presu.reduce((s: number, p: any) => s + Number(p.monto || 0), 0), approved: approvedPr.reduce((s: number, p: any) => s + Number(p.monto || 0), 0), pending: pendPr.reduce((s: number, p: any) => s + Number(p.monto || 0), 0), currency: "ARS" }, topAreas }); }}
            onExportMonthly={() => { const today = new Date(); const monthAgo = new Date(today.getFullYear(), today.getMonth() - 1, today.getDate()); const fmtD2 = (d: Date) => d.toISOString().slice(0, 10); const range = fmtD2(monthAgo) + " al " + fmtD2(today); const ok = peds.filter((p: any) => p.st === ST.OK); const pend = peds.filter((p: any) => p.st === ST.P); const od = peds.filter((p: any) => p.st !== ST.OK && isOD(p.fReq)); const approvedPr = presu.filter((pr: any) => pr.status === "aprobado"); const pendPr = presu.filter((pr: any) => pr.status !== "aprobado" && pr.status !== "rechazado"); const topAreas = areas.map((a: any) => { const dIds = deptos.filter((d: any) => d.aId === a.id).map((d: any) => d.id); const aP = peds.filter((p: any) => dIds.indexOf(p.dId) >= 0); const aOk = aP.filter((p: any) => p.st === ST.OK).length; return { name: a.name, total: aP.length, completed: aOk, pct: aP.length ? Math.round(aOk / aP.length * 100) : 0 }; }).filter((a: any) => a.total > 0); exportReportPDF({ period: "Mensual", dateRange: range, stats: [{ label: "Total tareas", value: String(peds.length), color: "#0A1628" }, { label: "Completadas", value: String(ok.length), color: "#10B981" }, { label: "Pendientes", value: String(pend.length), color: "#DC2626" }, { label: "Vencidas", value: String(od.length), color: "#7C3AED" }], tasksByStatus: Object.keys(SC).map(k => ({ status: SC[k].l, icon: SC[k].i, count: peds.filter((p: any) => p.st === k).length, color: SC[k].c })), completedTasks: ok.slice(0, 20).map((p: any) => { const ag = users.find((u: any) => u.id === p.asTo); return { id: p.id, desc: p.desc, assignee: ag ? fn(ag) : "‚Äì", date: p.fReq }; }), pendingTasks: [...od, ...pend].slice(0, 20).map((p: any) => { const ag = users.find((u: any) => u.id === p.asTo); return { id: p.id, desc: p.desc, assignee: ag ? fn(ag) : "‚Äì", date: p.fReq, overdue: p.st !== ST.OK && isOD(p.fReq) }; }), budgetSummary: { total: presu.reduce((s: number, p: any) => s + Number(p.monto || 0), 0), approved: approvedPr.reduce((s: number, p: any) => s + Number(p.monto || 0), 0), pending: pendPr.reduce((s: number, p: any) => s + Number(p.monto || 0), 0), currency: "ARS" }, topAreas }); }}
          />}
          {vw === "dash" && !isPersonal && !aA && !aD && kpiFilt && (() => { const fl = KPIF[kpiFilt]; const fp = kpiFilter(peds, kpiFilt); return <div><Bread parts={[{ label: "Dashboard", onClick: () => sKpiFilt(null) }, { label: fl?.l || "" }]} mob={mob} /><TList title={fl?.l || ""} icon={fl?.i || ""} color={fl?.c || T.bl} peds={fp} onSel={(p: any) => sSl(p)} search={searchTerm} mob={mob} onBulk={handleBulk} onImport={handleImport} user={user} /></div>; })()}
          {vw === "dash" && !isPersonal && aA && !aD && (aA === 100 || aA === 101) && (() => { const selAr = areas.find((a: any) => a.id === aA); return <div><Bread parts={[{ label: "Dashboard", onClick: () => { sAA(null); sKpiFilt(null); } }, { label: selAr?.name || "" }]} mob={mob} /><h2 style={{ margin: "0 0 4px", fontSize: mob ? 16 : 19, color: colors.nv, fontWeight: 800 }}>{selAr?.icon} {selAr?.name}</h2><p style={{ color: colors.g4, fontSize: 12, margin: "0 0 16px" }}>{deptos.filter((d: any) => d.aId === aA).length} cargos</p><KPIs peds={vP} mob={mob} onFilter={(k: string) => { sAA(null); sKpiFilt(k); }} /><DeptCircles area={selAr} onDC={(id: number) => sAD(id)} mob={mob} /></div>; })()}
          {vw === "dash" && !isPersonal && aA && !aD && aA !== 100 && aA !== 101 && (() => { const selAr = areas.find((a: any) => a.id === aA); return <div><Bread parts={[{ label: "Dashboard", onClick: () => { sAA(null); sKpiFilt(null); } }, { label: selAr?.name || "" }]} mob={mob} /><h2 style={{ margin: "0 0 4px", fontSize: mob ? 16 : 19, color: colors.nv, fontWeight: 800 }}>{selAr?.icon} {selAr?.name}</h2><p style={{ color: colors.g4, fontSize: 12, margin: "0 0 16px" }}>{deptos.filter((d: any) => d.aId === aA).length} departamentos</p><KPIs peds={vP} mob={mob} onFilter={(k: string) => { sAA(null); sKpiFilt(k); }} /><DeptCircles area={selAr} onDC={(id: number) => sAD(id)} mob={mob} /></div>; })()}
          {vw === "dash" && !isPersonal && aD && (() => { const selAr = areas.find((a: any) => a.id === aA); const selDp = deptos.find((d: any) => d.id === aD); return <div><Bread parts={[{ label: "Dashboard", onClick: () => { sAA(null); sAD(null); sKpiFilt(null); } }, { label: selAr?.name || "", onClick: () => { sAD(null); sKpiFilt(null); } }, { label: selDp?.name || "" }]} mob={mob} /><TList title={vT} icon={vI} color={vC} peds={vP} onSel={(p: any) => sSl(p)} search={searchTerm} mob={mob} onBulk={handleBulk} onImport={handleImport} user={user} /></div>; })()}
          </>}
        </main>
      </div>
      {showPw && <ChangePw onX={() => sShowPw(false)} />}
      {sel && <Det p={peds.find(x => x.id === sel.id) || sel} user={user} onX={() => sSl(null)} mob={mob}
        onDup={async (p: any) => { try { const ts = TODAY + " " + new Date().toTimeString().slice(0, 5); const row: any = taskToDB({ ...p, st: ST.P, asTo: null, resp: "", monto: null, eOk: null, cAt: TODAY, cId: user.id, cN: fn(user) }); const { data, error } = await supabase.from("tasks").insert(row).select().single(); if (error) throw new Error(error.message); const tid = data?.id || 0; const newP = { ...p, id: tid, st: ST.P, asTo: null, resp: "", monto: null, eOk: null, cAt: TODAY, cId: user.id, cN: fn(user), log: [{ dt: ts, uid: user.id, by: fn(user), act: "Cre√≥ tarea (duplicada de #" + p.id + ")", t: "sys" }] }; sPd(ps => [newP, ...ps]); await supabase.from("task_messages").insert({ task_id: tid, user_id: user.id, user_name: fn(user), content: "Cre√≥ tarea (duplicada de #" + p.id + ")", type: "sys" }); sSl(newP); showT("Tarea duplicada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onCheck={async (id: number, items: any[]) => { try { for (const item of items) { await supabase.from("task_messages").upsert({ task_id: id, user_id: user.id, user_name: fn(user), content: JSON.stringify(item), type: "check" }); } const ts = TODAY + " " + new Date().toTimeString().slice(0, 5); sPd(p => p.map(x => x.id === id ? { ...x, log: [...(x.log || []).filter((l: any) => l.t !== "check"), ...items.map(item => ({ dt: ts, uid: user.id, by: fn(user), act: JSON.stringify(item), t: "check" }))] } : x)); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onAddPresu={async (d: any) => { try { const row = presuToDB(d); const { data, error } = await supabase.from("presupuestos").insert(row).select().single(); if (error) throw new Error(error.message); sPr(p => [presuFromDB(data), ...p]); showT("Presupuesto agregado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onUpdPresu={async (id: number, d: any) => { try { const prev = presu.find(x => x.id === id); sPr(p => p.map(x => x.id === id ? { ...x, ...d } : x)); await supabase.from("presupuestos").update(d).eq("id", id); if (d.status && prev && d.status !== prev.status && prev.solicitado_por) { const stLabel = d.status === "aprobado" ? "aprobado" : d.status === "rechazado" ? "rechazado" : d.status === "recibido" ? "recibido" : "actualizado"; const reqUser = users.find((u: any) => fn(u) === prev.solicitado_por || u.id === prev.solicitado_por); if (reqUser && reqUser.id !== user.id) sendNotif(reqUser.id, "Presupuesto " + stLabel, prev.descripcion?.slice(0, 60) || "", "budget"); } showT("Presupuesto actualizado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onDelPresu={async (id: number) => { try { sPr(p => p.filter(x => x.id !== id)); await supabase.from("presupuestos").delete().eq("id", id); showT("Presupuesto eliminado"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onTk={async (id: number) => { try { const prev = peds.find(x => x.id === id); const prevAsTo = prev?.asTo; sPd(p => p.map(x => x.id === id ? { ...x, asTo: user.id, st: ST.C } : x)); await supabase.from("tasks").update({ assigned_to: user.id, status: ST.C }).eq("id", id); addLog(id, user.id, fn(user), "Tom√≥ la tarea", "sys"); if (prevAsTo && prevAsTo !== user.id) sendNotif(prevAsTo, fn(user) + " tom√≥ la tarea #" + id, (prev?.tit || prev?.desc || "").slice(0, 60), "task"); if (prev?.cId && prev.cId !== user.id && prev.cId !== prevAsTo) sendNotif(prev.cId, fn(user) + " tom√≥ la tarea #" + id, (prev?.tit || prev?.desc || "").slice(0, 60), "task"); showT("Tarea tomada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onAs={async (id: number, uid: string) => { try { const ag = users.find(u => u.id === uid); const p2 = peds.find(x => x.id === id); const newSt = p2?.st === ST.P ? ST.C : p2?.st; sPd(p => p.map(x => x.id === id ? { ...x, asTo: uid, st: x.st === ST.P ? ST.C : x.st } : x)); await supabase.from("tasks").update({ assigned_to: uid, status: newSt }).eq("id", id); addLog(id, user.id, fn(user), "Asign√≥ a " + (ag ? fn(ag) : ""), "sys"); sendNotif(uid, "Te asignaron una tarea", p2?.desc || "", "task", "", true); showT("Tarea asignada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onRe={async (id: number, r: string) => { try { const sr = sanitize(r); sPd(p => p.map(x => x.id === id ? { ...x, resp: sr } : x)); await supabase.from("tasks").update({ resolution: sr }).eq("id", id); showT("Resoluci√≥n guardada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onSE={async (id: number) => { try { sPd(p => p.map(x => x.id === id ? { ...x, st: ST.E } : x)); await supabase.from("tasks").update({ status: ST.E }).eq("id", id); addLog(id, user.id, fn(user), "Envi√≥ a Compras", "sys"); users.filter(u => u.role === "embudo").forEach(u => sendNotif(u.id, "Nueva tarea en Compras", peds.find(x => x.id === id)?.desc || "", "budget")); showT("Enviado a Compras"); sSl(null); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onEO={async (id: number, ok: boolean) => { try { const p2 = peds.find(x => x.id === id); sPd(p => p.map(x => x.id === id ? { ...x, st: ST.C, eOk: ok } : x)); await supabase.from("tasks").update({ status: ST.C, expense_ok: ok }).eq("id", id); addLog(id, user.id, fn(user), ok ? "Compras aprob√≥" : "Compras rechaz√≥", "sys"); if (p2?.asTo) sendNotif(p2.asTo, ok ? "Gasto aprobado" : "Gasto rechazado", p2.desc || "", "budget"); if (p2?.cId && p2.cId !== p2.asTo) sendNotif(p2.cId, ok ? "Gasto aprobado" : "Gasto rechazado", p2.desc || "", "budget"); showT(ok ? "Gasto aprobado" : "Gasto rechazado"); sSl(null); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onFi={async (id: number) => { try { const p2 = peds.find(x => x.id === id); sPd(p => p.map(x => x.id === id ? { ...x, st: ST.V } : x)); await supabase.from("tasks").update({ status: ST.V }).eq("id", id); addLog(id, user.id, fn(user), "Envi√≥ a validaci√≥n", "sys"); if (p2?.cId) sendNotif(p2.cId, "Tarea lista para validar", p2.desc || "", "task"); showT("Enviado a validaci√≥n"); sSl(null); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onVa={async (id: number, ok: boolean) => { try { const p2 = peds.find(x => x.id === id); const ns = ok ? ST.OK : ST.C; sPd(p => p.map(x => x.id === id ? { ...x, st: ns } : x)); await supabase.from("tasks").update({ status: ns }).eq("id", id); addLog(id, user.id, fn(user), ok ? "Valid√≥ OK ‚úÖ" : "Rechaz√≥", "sys"); if (p2?.asTo) sendNotif(p2.asTo, ok ? "Tarea completada" : "Tarea rechazada", p2.desc || "", "task"); let autoInv = false; if (ok && p2?.rG && p2?.tipo === "Material deportivo") { const ag = users.find((u: any) => u.id === p2.asTo); const { data: invD } = await supabase.from("inventory").insert({ name: p2.desc || "Material", category: "deportivo", quantity: 1, condition: "nuevo", responsible_id: p2.asTo || null, responsible_name: ag ? fn(ag) : "", notes: "Auto tarea #" + id }).select().single(); if (invD) { sInventory(prev => [invD, ...prev]); autoInv = true; } } showT(ok ? (autoInv ? "Completada + Inventario" : "Tarea completada") : "Tarea rechazada"); sSl(null); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onMsg={async (id: number, txt: string) => { try { const safe = sanitize(txt); if (!safe) return; await addLog(id, user.id, fn(user), safe, "msg"); const p2 = peds.find(x => x.id === id); if (p2?.asTo && p2.asTo !== user.id) { sendNotif(p2.asTo, "Nuevo comentario en tarea #" + id, txt.slice(0, 80), "task"); } if (p2?.cId && p2.cId !== user.id && p2.cId !== p2.asTo) { sendNotif(p2.cId, "Nuevo comentario en tarea #" + id, txt.slice(0, 80), "task"); } const mentionRx = /@([\w\s]+?)(?=\s@|$)/g; let match; while ((match = mentionRx.exec(txt)) !== null) { const mName = match[1].trim(); const mUser = users.find((u: any) => (fn(u)).toLowerCase() === mName.toLowerCase()); if (mUser && mUser.id !== user.id && mUser.id !== p2?.asTo && mUser.id !== p2?.cId) { sendNotif(mUser.id, "Te mencionaron en tarea #" + id, txt.slice(0, 80), "task"); } } } catch { showT("Error al enviar mensaje", "err"); } }}
        onMonto={async (id: number, m: number) => { try { sPd(p => p.map(x => x.id === id ? { ...x, monto: m } : x)); await supabase.from("tasks").update({ amount: m }).eq("id", id); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onDel={async (id: number) => { try { sPd(p => p.filter(x => x.id !== id)); await supabase.from("tasks").delete().eq("id", id); showT("Tarea eliminada"); sSl(null); } catch (e: any) { showT(e.message || "Error", "err"); } }}
        onEditSave={async (id: number, d: any) => { try { const sd = { ...d, tit: (d.tit || "").trim(), desc: sanitize(d.desc || "") }; sPd(p => p.map(x => x.id === id ? { ...x, ...sd } : x)); await supabase.from("tasks").update({ title: sd.tit, tipo: sd.tipo, description: sd.desc, due_date: sd.fReq, urgency: sd.urg, division: sd.div || "", requires_expense: sd.rG }).eq("id", id); addLog(id, user.id, fn(user), "Edit√≥ la tarea", "sys"); showT("Tarea actualizada"); } catch (e: any) { showT(e.message || "Error", "err"); } }}
      />}
      <NotificationPanel user={user} mob={mob} shNot={shNot} sShNot={sShNot} shNotifPrefs={shNotifPrefs} sShNotifPrefs={sShNotifPrefs} computedNts={computedNts} dbNotifs={dbNotifs} ntGrouped={ntGrouped} ntColor={ntColor} unreadDb={unreadDb} badgeCount={badgeCount} notifFilter={notifFilter} sNotifFilter={sNotifFilter} notifPage={notifPage} sNotifPage={sNotifPage} notifTotal={notifTotal} NOTIF_LIMIT={NOTIF_LIMIT} refreshNotifs={refreshNotifs} pushEnabled={pushEnabled} requestPush={requestPush} getToken={getToken} sDbNotifs={sDbNotifs} sVw={sVw} sSl={sSl} sAA={sAA} sAD={sAD} />
      <CommandPalette open={cmdOpen} onClose={() => sCmdOpen(false)} items={cmdItems} />
      {toast && <Toast msg={toast.msg} type={toast.type} onDone={() => sToast(null)} />}
    </div>
    </ThemeCtx.Provider>
    </ErrorBoundary>
  );
}
